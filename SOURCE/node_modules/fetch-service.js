const browservm = require('browservm')

module.exports = fetch_service

// @TODO: try to send some requests in parallel and see if they all resolve correctly

async function fetch_service ({controller = new AbortController()}) {
  const provision = await browservm({controller})
  const to = provision.url
  const by = location.href
  var id = 0
  const send = provision(script, onmessage)
  const pending = {}
  var _resolve
  var _reject
  // const button = document.createElement('button')
  // button.innerHTML = 'focus: ' + provision.id
  // button.onclick = () => window.open('', provision.id)
  // document.body.append(button)
  return new Promise((resolve, reject) => {
    _resolve = resolve
    _reject = reject
  })
  function fetch (url) {
    const head = [by, to, id++]
    const type = 'fetch'
    const data = url
    const message = { head, refs: {}, type, data, meta: { time: Date.now(), stack: new Error().stack } }
    console.log('10: [parent] fetching', { message })
    send(message)
    return new Promise((resolve, reject) => {
      pending[head] = { resolve, timeout: setTimeout(() => {
        pending[head] = null
        // @TODO: check if postMessage supports "abort"
        const error = new Error('Request Timeout')
        console.error(error, message)
        reject(error)
      }, 5000)}
    })
  }
  function onmessage (message) {
    console.log('18: [parent] RECEIVED', message)
    // can now use fetch!
    const action = {
      'exit'  : message => { controller.abort(); message.data && console.error(message) },
      'data'  : message => {
        console.log('19: [parent] DATA', message)
        try {
          console.log({pending})
          const key = message.refs.cause.toString()
          const val = pending[key]
          console.log({key, val})
          const { resolve, timeout } = pending[message.refs.cause]
          clearTimeout(timeout)
          resolve(message.data)
        } catch (error) {
          console.log('timeout fetch response', {error, message})
        }
      },
      'init'  : message => {
        fetch.help = message.data
        Object.freeze(fetch)
        action.init = resolve = _reject = void _resolve(fetch)
      }
    }
    const handler = action[message.type]
    if (!handler) {
      // controller.abort()
      console.error('QUIT', message)
      throw new Error('recieved invalid message')
    }
    handler(message)
  }
  function script (url, name) {
    const forigin = new URL(url).origin
    const context = (opener || parent)
    console.log('5: [vm] EXECUTING SCRIPT', { url, href: location.href})
    const send = (d, o = '*', t) => {
      console.log('send', d)
      console.log({url, name})
      console.log(window === context)
      console.log(context)
      context.postMessage(d, o, t)
    }
    const by = location.href
    var mid = 0
    localStorage.command = ''
    async function grab (callback) {
      callback()
      const { command } = localStorage
      console.log({command})
      if (!command) return
      console.log('14: [iframe] PICKED UP')
      const { msg, req } = JSON.parse(command)
      const request = req
      console.log('15: [iframe] REQUEST', {request})
      const response = await fetch(request.url, request)
      console.log('16: [iframe] RESPONSE', {response})
      const blob = await response.blob()
      const data = {}
      data.url = response.url
      data.type = response.type
      data.status = response.status
      data.statusText = response.statusText
      data.redirected = response.redirected
      data.ok = response.ok
      data.headers = [...response.headers].reduce(to_object, {})
      data.blob = blob
      msg.data = data
      localStorage.command = ''
      console.log("17: [iframe] EMIT", { msg })
      send(msg)
    }
    function to_object (obj, x) { obj[x[0]] = x[1]; return obj }
    const action = {
      'exit': message => { send({ type: 'exit', data: message }); window.close() },
      'fetch': async nessage => {
        grab(async () => {
          const { head, data: request } = nessage
          const [to, by] = head
          localStorage.command = JSON.stringify({
            msg: {
              head: [by, to, mid++],
              refs: { cause: head },
              type: 'data',
            },
            req: request
          })
          console.log('13: [iframe] STORED')
          // debugger
          // console.log('REQ', request)
          // const response = await fetch(request.url, request)
          // const data = {}
          // data.url = response.url
          // data.type = response.type
          // data.statys = response.statys
          // data.responseText = response.responseText
          // data.redirected = response.redirected
          // data.ok = response.ok
          // data.headers = response.headers
          // data.blob = await response.blob()
          // send({
          //   head: [by, to, mid++],
          //   refs: { cause: head },
          //   type: 'data',
          //   data,
          // })
        }, 100)
      }
    }
    onmessage = event => {
      const { data: message, origin } = event
      console.log('12: [iframe] RECEIVE', { origin, forigin, message })
      if (origin !== forigin) return
      const handler = action[message.type] || action['exit']
      handler(message)
    }
    // const button = document.createElement('button')
    // button.innerHTML = 'focus: ' + name
    // button.onclick = () =>  window.open('', name)
    // document.body.append(button)
    // console.log('FOCUS BACK')
    // // const btn = [...document.body.querySelectorAll('button')].at(-1)
    // // setTimeout(() => btn.click(), 1000)
    console.log('6: [vm] EMITTING INIT: ready => init')
    const time = `${Date.now()}`
    const stack = `${new Error().stack}`
    ;(opener || parent).postMessage(({
      head: [by, url, mid++],
      refs: { },
      type: 'init',
      data: Object.keys(action),
      meta: { time, stack },
    }), '*')
    // send({
    //   head: [by, url, mid++],
    //   refs: { },
    //   type: 'init',
    //   data: Object.keys(action),
    //   meta: { time: Date.now(), stack: new Error().stack },
    // })
  }
}