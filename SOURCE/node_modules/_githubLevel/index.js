#!/usr/bin/env node
'use strict';
/******************************************************************************
  DEPENDENCIES = CUSTOM SDK [Custom Software Development Kit]
******************************************************************************/
// var path    = require('path');
const fetch_service = require('fetch-service');
var minixhr = require('minixhr');
var levelup = require('levelup');
var leveljs = require('level-js');
// var version = require('level-version');
// // a version stream for a single key between versions 100 and 1000
// db.createVersionStream(key, {minVersion: 100, maxVersion: 1000}).pipe(/* ... */)
//
// // stream all keys, but only the most recent version of each
// db.createReadStream({versionLimit: 1}).pipe(/* ... */)
/******************************************************************************
  PARAMETER = ARGUMENT
******************************************************************************/
  // no cli tool
/******************************************************************************
  MODE
******************************************************************************/
  // just browser
/******************************************************************************
  MODULE INTERNALS & HELPERS
******************************************************************************/
var DBname  = location.href;
var db      = levelup(DBname, { db: leveljs });
// var origin      = levelup(DBname, { db: leveljs });
// var db      = version(origin);
var logErr  = console.error.bind(console);
var logInfo = console.info.bind(console);

var service


async function levelGithub (parameter, callback) {
  // callback(error, data, version)
  if (!parameter || !callback) { return }

  const controller = new AbortController()
  fetch = service || (service = await fetch_service({controller}))


  // console.log('fetch service')
  // const public_suffix_list_url = 'https://raw.githubusercontent.com/publicsuffix/list/master/public_suffix_list.dat'
  // const list = await fetch(public_suffix_list_url)
  // console.log({list})
  // return controller.abort()

  var url = parameter.url || '';

  // const suffixes = list.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('//')).reduce((obj, key) => (obj[key] = key, obj), {})

  db.get(url, async function (error, content, version) {
    content = validate(error, content)
    if (content.data) return callback(null, content, version)
    var request = { url }
    console.log('9: [parent] FETCHING', { request })
    const response = (await fetch(request))
    console.log('20: [parent] RESPONSE', {response})
    var action = {
      200: success,
      304: unchanged,
      403: limitReached,
      404: notFound
    }[response.status]
    action ? action() : onerror()

    // printRemaining(logInfo);

    // minixhr(request, function (data, response, xhr, header) {

   async function success() {
      console.log('success')
      const text = await response.blob.text()
      const { url, headers } = response
      var value = {
        ETag      : headers.etag,
        data      : text,
        url       : url
      };
      const json = JSON.stringify(value)
      console.log('STORING', { url, value })
      db.put(url, json, function (error, version) {
        if (error) {
          logErr('Could not store in IndexedDB');
          callback(null, value, null);
        } else {
          callback(null, value, version);
        }
      });
    }
    async function unchanged () {
      console.log('unchanged')
      printRemaining(logInfo);
      if (!content.data) {
        error();
      } else {
        callback(null, content.data, version);
      }
    }
    async function printRemaining (logger) {
      const { url, headers } = response
      console.log('printRemaining')
      var left  = +headers["X-RateLimit-Remaining"];
      var total = +headers["X-RateLimit-Limit"];
      var msg   = 'Remaining Requests: ' + left + '/' + total;
      logger(url);
    }
    async function notFound () {
      const { url } = response
      console.log('notFound')
      printRemaining(logErr);
      logErr(url);
      return
    }
    async function limitReached () {
      console.log('limitReached')
      printRemaining(logErr);
      notAvailable();
    }
    async function onerror () {
      console.log('onerror')
      logErr('STATUS: ' + xhr.status);
      logErr('Something went wrong.');
    }
    async function notAvailable () {
      console.log('notAvailable')
      var msg = 'Service temporarily not available - try again in one hour';
      callback(new Error(msg));
    }
  })
}
function clearDB () {
  indexedDB.webkitGetDatabaseNames().onsuccess = function(sender,args) {
    logInfo(sender.target.result);
    var result = sender.target.result;
    for(var length = result.length, idx=0;idx<length; idx++) {
      logInfo(result[idx]);
      if (result[idx] === DBname) {
        indexedDB.deleteDatabase(result[idx]).onsuccess = function () {
          logInfo(arguments);
        };
      }
    }
  };
}
function validate (error, content) {
  if (error && error.type !== 'NotFoundError') {
    throw error;
  } else if (error) {
    content = {};
  } else {
    content = JSON.parse(content);
  }
  return content;
}
levelGithub.clearDB = clearDB;
/******************************************************************************
  EXPORT
******************************************************************************/
module.exports = levelGithub;
